---
title: "Section 3: Wrangling with `dplyr`"
author: "Matt Higham"
format: 
  html:
    embed-resources: true
---

```{r}
library(babynames)
library(tidyverse)
babynames

stat113_df
babynames_matthew <- babynames |>
  filter(name == "Matthew" & sex == "M" & year >= 1900)

ggplot(data = babynames_matthew, aes(x = year, y = n)) +
  geom_line()
```

## Class Exercises 

Class Exercise 1

```{r}
babynames_m10 <- babynames |>
  filter(year == 2017 & sex == "M") |>
  arrange(desc(n)) |>
  slice(1:10)
```

Class Exercise 2

```{r}
babynames_m10 <- babynames_m10 |> mutate(name_ord = fct_reorder(name, n))
ggplot(data = babynames_m10, aes(x = name_ord, y = n)) +
  geom_col() +
  coord_flip()

fct_
```

Class Exercise 3

```{r}
babynames_zelda <- babynames |>
  filter(name == "Zelda" & sex == "F")

## class exercise 4

ggplot(data = babynames_zelda, aes(x = year, y = n)) +
  geom_line()
```

Class Exercise 5

```{r}
fitness_df <- read_csv("https://raw.githubusercontent.com/highamm/ds234_quarto/main/data_online/higham_fitness_clean.csv",
                         col_types = list(stepgoal = col_factor())) |>
  mutate(weekend_ind = case_when(weekday == "Sat" | weekday == "Sun" ~ "weekend",
                                 TRUE ~ "weekday"))
fitness_df |> mean(distance)
```

fitness_df becomes the first argument to mean(), but the first argument of mean() cannot be a data frame.

## Your Turn

Your Turn 1

```{r}
## a
babynames |> filter(year != 1945)

## b
babynames |> filter(n > 400 & n < 5000)

## c
babynames_hm <- babynames |>
  filter((name == "Hilary" & sex == "F") | (name == "Monica" & sex == "F"))
```

Your Turn 2

```{r}
ggplot(data = babynames_hm, aes(x = year, y = n, colour = name)) +
  geom_line()
```


Your Turn 3

```{r}
babynames_5 <- babynames |>
  filter((name == "Matthew" & sex == "M") | 
           (name == "Jessica" & sex == "F") |
           (name == "Ivan" & sex == "M") |
           (name == "Robin" & sex == "M") |
           (name == "Michael" & sex == "M"))

ggplot(data = babynames_5, aes(x = year, y = n,
                               colour = name)) +
  geom_line()
```

Your Turn 4

```{r}
babynames_f91 <- babynames |>
  filter(sex == "F" & year == 1991) |>
  arrange(desc(n)) |>
  slice(1:10)

ggplot(data = babynames_f91, aes(x = name, y = prop)) +
  geom_col()
```


```{r}
library(tidyverse)
slumajors_df <- read_csv("https://raw.githubusercontent.com/highamm/ds234_quarto/main/data_online/SLU_Majors_17_21.csv")

slumajors_df <- slumajors_df |>
  mutate(ntotal = nfemales + nmales) |>
  mutate(percfemale = 100 * nfemales / (nfemales + nmales))
slumajors_df <- slumajors_df |>
  mutate(morewomen = if_else(percfemale > 50,
                             true = "Yes",
                             false = "No")) |>
  mutate(large_majority =
           case_when(percfemale >= 70 ~ "female",
                     percfemale <= 30 ~ "male",
                     percfemale > 30 & percfemale < 70 ~ "none")) 
```

## Class Exercises

Class Exercise 1

There might be reasons for either choice, but the exercise shows that there usually is some subjectivity in a data analysis.

Class Exercise 2

In general, we would all like to be as inclusive as possible but we also want to account for the anonymous nature of the Stat 113 survey.Class

Class Exercise 3

```{r}
slumajors_df |>
  mutate(testcase = case_when(percfemale >= 40 ~ "Yes",
                              percfemale > 60 ~ "No")) |>
  relocate(testcase)
## case_when evaluates the conditions you provide in order
## rows that satisfy none of the conditions get an "NA"
```

Class Exercise 4

```{r}
library(babynames)
babynames_pop <- babynames |> group_by(year, sex) |> 
  mutate(rank_pop = rank(desc(n)))

## class exercise 5
babynames_pop |> filter(rank_pop == 1) |>
  ungroup() |>
  group_by(name) |>
  summarise(n_appear = n()) |>
  arrange(desc(n_appear))

# babynames_pop <- babynames |> group_by(year, sex) |> 
#   mutate(rank_pop = rank(desc(n)))
# babynames_pop |> filter(rank_pop == 1) |>
#   summarise(n_appear = n()) |>
#   arrange(desc(n_appear))


```

Class Exercise 6

```{r}
babynames_test <- babynames |>
  group_by(year, sex) |> mutate(ntest = n / prop)
babynames_test |> ungroup() |> slice(1, 2, 3, 4, 5)
```

Your Turn 1

```{r}
toy_df <- tibble(x = c(NA, 3, 4, 7),
                 y = c(1, 4, 3, 2),
                 z = c("A", "A", "B", NA))

## a
toy_df |> group_by(z) |>
  mutate(sum_x_y = x + y,
         max_y = max(y))

## b
toy_df |> group_by(z) |>
  slice(1, 2) ## obtain the first two rows for each group

## c
toy_df |> group_by(z) |>
  filter(y > 2)
toy_df |> group_by(z) |>
  filter(y == max(y))

## d
toy_df |> group_by(z) |>
  arrange(desc(y))
## arrange() ignores the grouping structure
## look into arrange() and grouping

## e
toy_df |> group_by(z) |>
  select(x)
## group_by(z) means that z will be kept in the data frame
```

Your Turn 2

```{r}
## a
toy_df |> mutate(sum_x_y = x + y)
## any NA values are still NA in the new variable

toy_df |> arrange(x)
toy_df |> arrange(desc(x))
## NA always go last

## c
toy_df |> filter(x < 4)
## NA is dropped in the condition

## d
toy_df |>
  summarise(mean_x = mean(x))
## returns NA because we don't know one of the x values
toy_df |>
  summarise(mean_x = mean(x, na.rm = TRUE))

## e
toy_df |>
  group_by(z) |>
  summarise(mean_x = mean(x))
## for the group where x is missing, the mean value is also
## missing.
## NA gets treated as its own group for z
```

Your Turn 3

a. Yes, mutate() is generally safe to do this with because we are just adding a new variable.

b. Yes, arrange is fine too: we still have all of the rows and columnns  (the rows are just in a different order).

c. No, because the rows that are removed with filter are gone "forever". (same logic for slice)

d. No, summarise will collapse the data set so we cannot go back and use the original variables.

e. No, because columns that are removed are gone (unless we are absolutely sure we never want to use the variables that are removed again).


Your Turn 4

```{r}
slumajors_df |>
  summarise(meantotalmajor = mean(ntotal),
            totalgrad = sum(ntotal)) 
slumajors_df |>
  mutate(meantotalmajor = mean(ntotal),
            totalgrad = sum(ntotal)) |>
  select(meantotalmajor, totalgrad, everything())
```

summarise() returns one row for each group that you are summarising over (one row total in this case because we did not use group_by). And, summarise() keeps only the new variables that you create within summarise() (as well a column for each group).

mutate() returns the same number of rows as the original data frame and simply adds columns for each new variable we create.


Your Turn 5

```{r}
babynames_uniqueyear <- babynames |> group_by(year) |>
  summarise(n_unique = n())
ggplot(data = babynames_uniqueyear, aes(x = year, y = n_unique)) +
  geom_line()
```

Your Turn 6

```{r}
babynames_uniqueyearsex <- babynames |> group_by(year, sex) |>
  summarise(n_unique = n())

ggplot(data = babynames_uniqueyearsex, aes(x = year, y = n_unique, colour = sex)) +
  geom_line()
```

Your Turn 7

```{r}
babynames |> group_by(name) |>
  summarise(n_births = sum(n)) |>
  arrange(desc(n_births))
```